// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package usr

import (
	"cloud.google.com/go/datastore"
	context "context"
	"sync"
)

// Ensure, that StoreMock does implement Store.
// If this is not the case, regenerate this file with moq.
var _ Store = &StoreMock{}

// StoreMock is a mock implementation of Store.
//
// 	func TestSomethingThatUsesStore(t *testing.T) {
//
// 		// make and configure a mocked Store
// 		mockedStore := &StoreMock{
// 			createFunc: func(ctx context.Context, tx *datastore.Transaction, user *User) error {
// 				panic("mock out the create method")
// 			},
// 			createMembersFunc: func(ctx context.Context, tx *datastore.Transaction, user *User) error {
// 				panic("mock out the createMembers method")
// 			},
// 			findFunc: func(ctx context.Context, tx *datastore.Transaction, userID UserID) (*User, error) {
// 				panic("mock out the find method")
// 			},
// 			findMembersFunc: func(ctx context.Context, tx *datastore.Transaction, userID UserID) ([]*Member, error) {
// 				panic("mock out the findMembers method")
// 			},
// 		}
//
// 		// use mockedStore in code that requires Store
// 		// and then make assertions.
//
// 	}
type StoreMock struct {
	// createFunc mocks the create method.
	createFunc func(ctx context.Context, tx *datastore.Transaction, user *User) error

	// createMembersFunc mocks the createMembers method.
	createMembersFunc func(ctx context.Context, tx *datastore.Transaction, user *User) error

	// findFunc mocks the find method.
	findFunc func(ctx context.Context, tx *datastore.Transaction, userID UserID) (*User, error)

	// findMembersFunc mocks the findMembers method.
	findMembersFunc func(ctx context.Context, tx *datastore.Transaction, userID UserID) ([]*Member, error)

	// calls tracks calls to the methods.
	calls struct {
		// create holds details about calls to the create method.
		create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx *datastore.Transaction
			// User is the user argument value.
			User *User
		}
		// createMembers holds details about calls to the createMembers method.
		createMembers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx *datastore.Transaction
			// User is the user argument value.
			User *User
		}
		// find holds details about calls to the find method.
		find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx *datastore.Transaction
			// UserID is the userID argument value.
			UserID UserID
		}
		// findMembers holds details about calls to the findMembers method.
		findMembers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx *datastore.Transaction
			// UserID is the userID argument value.
			UserID UserID
		}
	}
	lockcreate        sync.RWMutex
	lockcreateMembers sync.RWMutex
	lockfind          sync.RWMutex
	lockfindMembers   sync.RWMutex
}

// create calls createFunc.
func (mock *StoreMock) create(ctx context.Context, tx *datastore.Transaction, user *User) error {
	if mock.createFunc == nil {
		panic("StoreMock.createFunc: method is nil but Store.create was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Tx   *datastore.Transaction
		User *User
	}{
		Ctx:  ctx,
		Tx:   tx,
		User: user,
	}
	mock.lockcreate.Lock()
	mock.calls.create = append(mock.calls.create, callInfo)
	mock.lockcreate.Unlock()
	return mock.createFunc(ctx, tx, user)
}

// createCalls gets all the calls that were made to create.
// Check the length with:
//     len(mockedStore.createCalls())
func (mock *StoreMock) createCalls() []struct {
	Ctx  context.Context
	Tx   *datastore.Transaction
	User *User
} {
	var calls []struct {
		Ctx  context.Context
		Tx   *datastore.Transaction
		User *User
	}
	mock.lockcreate.RLock()
	calls = mock.calls.create
	mock.lockcreate.RUnlock()
	return calls
}

// createMembers calls createMembersFunc.
func (mock *StoreMock) createMembers(ctx context.Context, tx *datastore.Transaction, user *User) error {
	if mock.createMembersFunc == nil {
		panic("StoreMock.createMembersFunc: method is nil but Store.createMembers was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Tx   *datastore.Transaction
		User *User
	}{
		Ctx:  ctx,
		Tx:   tx,
		User: user,
	}
	mock.lockcreateMembers.Lock()
	mock.calls.createMembers = append(mock.calls.createMembers, callInfo)
	mock.lockcreateMembers.Unlock()
	return mock.createMembersFunc(ctx, tx, user)
}

// createMembersCalls gets all the calls that were made to createMembers.
// Check the length with:
//     len(mockedStore.createMembersCalls())
func (mock *StoreMock) createMembersCalls() []struct {
	Ctx  context.Context
	Tx   *datastore.Transaction
	User *User
} {
	var calls []struct {
		Ctx  context.Context
		Tx   *datastore.Transaction
		User *User
	}
	mock.lockcreateMembers.RLock()
	calls = mock.calls.createMembers
	mock.lockcreateMembers.RUnlock()
	return calls
}

// find calls findFunc.
func (mock *StoreMock) find(ctx context.Context, tx *datastore.Transaction, userID UserID) (*User, error) {
	if mock.findFunc == nil {
		panic("StoreMock.findFunc: method is nil but Store.find was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Tx     *datastore.Transaction
		UserID UserID
	}{
		Ctx:    ctx,
		Tx:     tx,
		UserID: userID,
	}
	mock.lockfind.Lock()
	mock.calls.find = append(mock.calls.find, callInfo)
	mock.lockfind.Unlock()
	return mock.findFunc(ctx, tx, userID)
}

// findCalls gets all the calls that were made to find.
// Check the length with:
//     len(mockedStore.findCalls())
func (mock *StoreMock) findCalls() []struct {
	Ctx    context.Context
	Tx     *datastore.Transaction
	UserID UserID
} {
	var calls []struct {
		Ctx    context.Context
		Tx     *datastore.Transaction
		UserID UserID
	}
	mock.lockfind.RLock()
	calls = mock.calls.find
	mock.lockfind.RUnlock()
	return calls
}

// findMembers calls findMembersFunc.
func (mock *StoreMock) findMembers(ctx context.Context, tx *datastore.Transaction, userID UserID) ([]*Member, error) {
	if mock.findMembersFunc == nil {
		panic("StoreMock.findMembersFunc: method is nil but Store.findMembers was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Tx     *datastore.Transaction
		UserID UserID
	}{
		Ctx:    ctx,
		Tx:     tx,
		UserID: userID,
	}
	mock.lockfindMembers.Lock()
	mock.calls.findMembers = append(mock.calls.findMembers, callInfo)
	mock.lockfindMembers.Unlock()
	return mock.findMembersFunc(ctx, tx, userID)
}

// findMembersCalls gets all the calls that were made to findMembers.
// Check the length with:
//     len(mockedStore.findMembersCalls())
func (mock *StoreMock) findMembersCalls() []struct {
	Ctx    context.Context
	Tx     *datastore.Transaction
	UserID UserID
} {
	var calls []struct {
		Ctx    context.Context
		Tx     *datastore.Transaction
		UserID UserID
	}
	mock.lockfindMembers.RLock()
	calls = mock.calls.findMembers
	mock.lockfindMembers.RUnlock()
	return calls
}
